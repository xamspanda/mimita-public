// // C:\important\quiet\n\mimita-public\mimita-public\src\physics\collision-capsule-triangle.h
// // dec 16 2025
// /**
//  * purpose
//  * this has all the SB that we dont want in the phsics cpp file 
//  * so phsics just calls the functions 
//  * and its all nice and readable 
//  */

//  static glm::vec3 closestPointOnTriangle(
//     const glm::vec3& p,
//     const glm::vec3& a,
//     const glm::vec3& b,
//     const glm::vec3& c)
// {
//     // edges
//     glm::vec3 ab = b - a;
//     glm::vec3 ac = c - a;
//     glm::vec3 ap = p - a;

//     float d1 = glm::dot(ab, ap);
//     float d2 = glm::dot(ac, ap);
//     if (d1 <= 0.0f && d2 <= 0.0f) return a;

//     glm::vec3 bp = p - b;
//     float d3 = glm::dot(ab, bp);
//     float d4 = glm::dot(ac, bp);
//     if (d3 >= 0.0f && d4 <= d3) return b;

//     float vc = d1 * d4 - d3 * d2;
//     if (vc <= 0.0f && d1 >= 0.0f && d3 <= 0.0f)
//         return a + ab * (d1 / (d1 - d3));

//     glm::vec3 cp = p - c;
//     float d5 = glm::dot(ab, cp);
//     float d6 = glm::dot(ac, cp);
//     if (d6 >= 0.0f && d5 <= d6) return c;

//     float vb = d5 * d2 - d1 * d6;
//     if (vb <= 0.0f && d2 >= 0.0f && d6 <= 0.0f)
//         return a + ac * (d2 / (d2 - d6));

//     float va = d3 * d6 - d5 * d4;
//     if (va <= 0.0f && (d4 - d3) >= 0.0f && (d5 - d6) >= 0.0f)
//         return b + (c - b) * ((d4 - d3) / ((d4 - d3) + (d5 - d6)));

//     float denom = 1.0f / (va + vb + vc);
//     float v = vb * denom;
//     float w = vc * denom;
//     return a + ab * v + ac * w;
// }

// static glm::vec3 closestPointOnSegment(
//     const glm::vec3& p,
//     const glm::vec3& a,
//     const glm::vec3& b)
// {
//     glm::vec3 ab = b - a;
//     float t = glm::dot(p - a, ab) / glm::dot(ab, ab);
//     t = glm::clamp(t, 0.0f, 1.0f);
//     return a + ab * t;
// }

// static void collideCapsuleTriangle(
//     Player& p,
//     Capsule& cap,
//     glm::vec3& move,   // <-- NEW
//     const glm::vec3& oldPos,
//     const glm::vec3& a,
//     const glm::vec3& b,
//     const glm::vec3& c)
// {
//     // find closest triangle point to capsule line
//     glm::vec3 triPoint = closestPointOnTriangle(
//         closestPointOnSegment(
//             (a + b + c) / 3.0f, 
//             cap.a, 
//             cap.b),
//         a, b, c
//     );

//     // find closest capsule point to triangle
//     glm::vec3 capPoint = closestPointOnSegment(triPoint, cap.a, cap.b);

//     glm::vec3 delta = capPoint - triPoint;
//     float dist = glm::length(delta);

//     // collisions function
//     // dec 16 2025 i think literally everthing else in this file is fine
//     // we just have to make this good 
//     if (dist < cap.r && dist > ALMOST_ZERO)
//     {
//         glm::vec3 normal = delta / dist;

//         float into = glm::dot(move, normal);

//         if (into < 0.0f)
//         {
//             // remove movement INTO wall, keep slide
//             move -= normal * into;
//         }

//         if (normal.y > MAX_SLOPE_ANGLE)
//         {
//             p.onGround = true;
//             if (p.vel.y < 0.0f)
//                 p.vel.y = 0.0f;
//         }
//     }
// }
