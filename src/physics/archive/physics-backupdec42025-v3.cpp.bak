#include "physics.h"
#include "../camera.h"
#include <glm/glm.hpp>

// constants
const float GRAVITY    = -25.0f;
const float MOVE_SPEED = 7.0f;
const float JUMP_SPEED = 10.0f;

struct AABB {
    glm::vec3 min;
    glm::vec3 max;
};

// Temporary test walls
// later test this with real maps dec 4 2025 
std::vector<AABB> testWalls = {
    { { -5, 0, -5 }, { -4, 2,  5 } },   // wall 1
    { {  4, 0, -5 }, {  5, 2,  5 } },   // wall 2
};

static bool AABBOverlap(const AABB& a, const AABB& b) {
    return (a.min.x <= b.max.x && a.max.x >= b.min.x) &&
           (a.min.y <= b.max.y && a.max.y >= b.min.y) &&
           (a.min.z <= b.max.z && a.max.z >= b.min.z);
}

void updatePhysics(Player& p, const Mesh& world, GLFWwindow* w, float dt, const Camera& cam)
{
    // ---- movement direction (WASD) ----
    glm::vec3 forward = glm::normalize(glm::vec3(cam.front.x, 0, cam.front.z));
    glm::vec3 right   = glm::cross(forward, glm::vec3(0,1,0));

    glm::vec3 wish(0);

    if (glfwGetKey(w, GLFW_KEY_W)) wish += forward;
    if (glfwGetKey(w, GLFW_KEY_S)) wish -= forward;
    if (glfwGetKey(w, GLFW_KEY_A)) wish -= right;
    if (glfwGetKey(w, GLFW_KEY_D)) wish += right;

    if (glm::length(wish) > 0)
        wish = glm::normalize(wish);

    // horizontal movement
    p.vel.x = wish.x * MOVE_SPEED;
    p.vel.z = wish.z * MOVE_SPEED;

    // ---- gravity ----
    p.vel.y += GRAVITY * dt;

    // ---- jump ----
    if (p.onGround && glfwGetKey(w, GLFW_KEY_SPACE))
    {
        p.vel.y = JUMP_SPEED;
        p.onGround = false;
    }

    // apply movement
    p.pos += p.vel * dt;

    // -----------------------------------------
    // MINIMAL TRIANGLE COLLISION
    // -----------------------------------------
    float hx = p.hitboxSize.x * 0.5f;
    float hy = p.hitboxSize.y * 0.5f;
    float hz = p.hitboxSize.z * 0.5f;

    // player feet & center
    glm::vec3 center = p.pos;
    glm::vec3 feet   = p.pos - glm::vec3(0, hy, 0);

    float bestGround = -99999.0f;
    glm::vec3 groundNormal(0,1,0);

    // loop all triangles
    for (size_t i = 0; i < world.verts.size(); i += 3)
    {
        glm::vec3 v0 = world.verts[i+0].pos;
        glm::vec3 v1 = world.verts[i+1].pos;
        glm::vec3 v2 = world.verts[i+2].pos;

        // triangle normal
        glm::vec3 n = glm::normalize(glm::cross(v1 - v0, v2 - v0));

        // ------- wall pushing (horizontal) -------
        // only push sideways (ignore Y)
        glm::vec3 nH = glm::normalize(glm::vec3(n.x, 0, n.z));
        float dH = glm::dot((center - v0), nH);

        if (dH < hx) {  
            float push = hx - dH;
            p.pos += nH * push;
            p.vel.x = p.vel.z = 0;
        }

        // ------- ground (triangular floor) -------
        if (n.y > 0.2f)   // must be upward-facing
        {
            // project player feet to triangle plane
            float dist = glm::dot((feet - v0), n);
            float yProj = feet.y - dist;

            if (yProj > bestGround &&
                glm::dot(n, glm::cross(v1-v0, feet - v0)) >= 0 &&
                glm::dot(n, glm::cross(v2-v1, feet - v1)) >= 0 &&
                glm::dot(n, glm::cross(v0-v2, feet - v2)) >= 0)
            {
                bestGround = yProj;
                groundNormal = n;
            }
        }
    }

    // -----------------------------------------
    // APPLY GROUND SNAP
    // -----------------------------------------
    if (bestGround > -1e8)
    {
        float halfH = p.hitboxSize.y * 0.5f;
        float currentFeet = p.pos.y - halfH;

        if (currentFeet <= bestGround + 0.05f)
        {
            p.pos.y = bestGround + halfH;
            p.vel.y = 0;
            p.onGround = true;
        }
        else
        {
            p.onGround = false;
        }
    }
    else
    {
        p.onGround = false;
    }

}
